# 图表生成架构重构技术方案

## 📋 目录

1. [方案概述](#方案概述)
2. [当前架构分析](#当前架构分析)
3. [新架构设计](#新架构设计)
4. [技术实现方案](#技术实现方案)
5. [数据流设计](#数据流设计)
6. [接口设计](#接口设计)
7. [实现步骤](#实现步骤)
8. [风险评估与应对](#风险评估与应对)
9. [性能优化建议](#性能优化建议)

---

## 1. 方案概述

### 1.1 目标

将图表生成从 Dify AI 生成改为由外部程序（前端或后端）基于实际数据代码生成，Dify 仅负责生成文字分析报告，然后将图表和文字拼合生成最终报告。

### 1.2 核心优势

- ✅ **图表准确性**：基于实际数据生成，避免 AI 生成图表时的数据偏差
- ✅ **样式统一**：图表样式和类型可标准化，提升报告专业性
- ✅ **性能优化**：减少 Dify 工作流复杂度，提高响应速度
- ✅ **职责分离**：AI 专注于文本分析，图表生成由代码控制
- ✅ **可维护性**：图表生成逻辑集中管理，易于调试和优化
- ✅ **成本控制**：减少 Dify API 调用复杂度，可能降低 API 成本

### 1.3 方案对比

| 维度 | 当前方案 | 新方案 |
|------|---------|--------|
| 图表生成 | Dify AI 生成 ECharts 配置 | 外部程序基于数据生成 |
| 数据来源 | Dify 从文件提取 | 后端直接读取 Excel |
| 文字报告 | Dify 生成 | Dify 生成（不变）|
| 图表准确性 | 依赖 AI 理解 | 基于真实数据 |
| 样式控制 | AI 决定 | 代码标准化 |
| 性能 | 较慢（AI 处理） | 较快（代码生成）|

---

## 2. 当前架构分析

### 2.1 现有流程图

```
用户上传Excel
    ↓
后端保存文件
    ↓
调用Dify工作流（传入文件）
    ↓
Dify分析数据并生成报告
    ├─ 文字分析
    └─ ECharts配置代码块（```echarts ... ```）
    ↓
后端解析Dify返回文本
    ├─ 提取文字内容
    └─ 提取ECharts配置（parse_echarts_from_text）
    ↓
前端接收报告内容
    ├─ 渲染文字（Markdown）
    └─ 渲染图表（ECharts实例化）
    ↓
生成PDF时
    ├─ 前端导出图表为图片
    └─ 后端拼接文字和图片
```

### 2.2 关键代码位置

- **图表解析**：`backend/app/utils/echarts_parser.py` - `parse_echarts_from_text()`
- **报告生成**：`backend/app/api/v1/operation.py` - `generate_report()`
- **PDF生成**：`backend/app/utils/pdf_generator.py` - `generate_report_pdf()`
- **前端渲染**：`frontend/src/views/Operation/components/ReportDisplay.vue`

### 2.3 当前问题

1. **数据准确性**：AI 生成的图表配置可能包含错误或虚构数据
2. **样式不一致**：每次生成的图表样式可能不同
3. **性能开销**：AI 需要理解数据并生成图表配置，耗时较长
4. **维护困难**：图表生成逻辑分散在 Dify 工作流中，难以统一管理

---

## 3. 新架构设计

### 3.1 架构图

```
用户上传Excel
    ↓
后端保存文件
    ↓
并行处理：
    ├─ 路径A：读取Excel数据 → 后端生成图表配置
    └─ 路径B：调用Dify工作流 → 生成文字报告
    ↓
后端合并结果
    ├─ 文字内容（来自Dify）
    └─ 图表配置（来自后端代码）
    ↓
前端接收报告内容
    ├─ 渲染文字（Markdown）
    └─ 渲染图表（ECharts实例化）
    ↓
生成PDF时
    ├─ 前端导出图表为图片
    └─ 后端拼接文字和图片
```

### 3.2 核心组件

#### 3.2.1 数据提取服务（后端）

- **职责**：读取 Excel 文件，提取结构化数据
- **位置**：`backend/app/services/data_extractor.py`（新建）
- **功能**：
  - 读取 Excel 文件
  - 数据清洗和预处理
  - 返回结构化数据（DataFrame/JSON）

#### 3.2.2 图表生成服务（后端）

- **职责**：基于数据生成 ECharts 配置
- **位置**：`backend/app/services/chart_generator.py`（新建）
- **功能**：
  - 分析数据类型
  - 选择合适的图表类型
  - 生成标准化的 ECharts 配置

#### 3.2.3 Dify 文字生成服务（不变）

- **职责**：生成文字分析报告
- **位置**：`backend/app/services/dify_service.py`（修改）
- **功能**：
  - 调用 Dify 工作流
  - 仅返回文字内容（不再包含图表配置）

#### 3.2.4 报告合并服务（后端）

- **职责**：合并文字和图表
- **位置**：`backend/app/services/report_merger.py`（新建）
- **功能**：
  - 合并 Dify 文字和图表配置
  - 生成最终报告结构

---

## 4. 技术实现方案

### 4.1 方案A：后端生成图表（推荐）

#### 4.1.1 优势

- ✅ 数据安全：Excel 数据不离开后端
- ✅ 性能稳定：后端环境可控
- ✅ 统一管理：图表生成逻辑集中
- ✅ 易于扩展：可集成更多数据分析库

#### 4.1.2 实现要点

1. **数据提取**
   ```python
   # backend/app/services/data_extractor.py
   class DataExtractor:
       def extract_data(self, file_path: str) -> Dict[str, Any]:
           # 使用 pandas 读取 Excel
           # 返回结构化数据
   ```

2. **图表生成**
   ```python
   # backend/app/services/chart_generator.py
   class ChartGenerator:
       def generate_charts(self, data: Dict, analysis_request: str) -> List[Dict]:
           # 分析数据特征
           # 选择合适的图表类型
           # 生成 ECharts 配置
   ```

3. **Dify 调用修改**
   ```python
   # 修改 Dify 提示词，明确只生成文字，不生成图表
   # 修改解析逻辑，不再提取 echarts 代码块
   ```

### 4.2 方案B：前端生成图表

#### 4.2.1 优势

- ✅ 实时交互：用户可实时看到图表
- ✅ 前端渲染：利用浏览器性能
- ✅ 用户体验：图表生成更快

#### 4.2.2 实现要点

1. **数据传递**
   - 后端读取 Excel 后，将数据传递给前端
   - 前端使用 ECharts 直接生成图表

2. **问题**
   - ⚠️ 数据安全：Excel 数据暴露到前端
   - ⚠️ 性能：大文件可能影响前端性能
   - ⚠️ PDF 生成：需要前端导出图片后传给后端

### 4.3 推荐方案：后端生成 + 前端可选渲染

**混合方案**：后端生成图表配置，前端可选择：
- 直接使用配置渲染（当前方式）
- 或基于原始数据重新生成（未来扩展）

---

## 5. 数据流设计

### 5.1 详细数据流

```
1. 用户上传Excel文件
   └─> 后端保存到 uploads/

2. 用户提交分析需求
   └─> 后端接收：session_id, file_id, analysis_request

3. 后端并行处理（异步）
   
   A. 数据提取流程：
      ├─> 读取Excel文件（pandas/openpyxl）
      ├─> 数据清洗和预处理
      ├─> 提取关键指标和维度
      └─> 返回结构化数据
   
   B. Dify文字生成流程：
      ├─> 上传文件到Dify（或传base64）
      ├─> 调用Dify工作流（修改提示词：只生成文字分析）
      ├─> 接收Dify返回的文字内容
      └─> 清理和格式化文字

4. 图表生成（基于提取的数据）
   ├─> 分析数据类型和特征
   ├─> 根据analysis_request确定图表类型
   ├─> 生成ECharts配置
   └─> 返回图表配置列表

5. 报告合并
   ├─> 合并文字内容（来自Dify）
   ├─> 合并图表配置（来自后端）
   └─> 生成最终报告结构

6. 保存报告
   └─> 保存到数据库

7. 返回前端
   └─> 前端渲染文字和图表
```

### 5.2 数据结构设计

#### 5.2.1 数据提取结果

```python
{
    "raw_data": DataFrame,  # 原始数据
    "summary": {
        "row_count": int,
        "column_count": int,
        "columns": List[str],
        "data_types": Dict[str, str],
        "numeric_columns": List[str],
        "categorical_columns": List[str],
        "date_columns": List[str]
    },
    "statistics": {
        "numeric_stats": Dict[str, Dict],  # 数值列统计
        "categorical_counts": Dict[str, Dict]  # 分类列统计
    }
}
```

#### 5.2.2 图表配置结构（保持不变）

```python
{
    "type": str,  # line, bar, pie, scatter, etc.
    "title": str,
    "config": {
        # ECharts 标准配置
    },
    "data": {
        "xAxis": List,
        "series": List
    }
}
```

#### 5.2.3 最终报告结构（保持不变）

```python
{
    "text": str,  # 来自Dify的文字内容
    "charts": List[Dict],  # 来自后端生成的图表配置
    "tables": List[Dict],
    "metrics": Dict
}
```

---

## 6. 接口设计

### 6.1 新增接口

#### 6.1.1 数据提取接口（可选，用于调试）

```python
POST /api/v1/operation/extract-data
Request:
{
    "file_id": int
}
Response:
{
    "success": true,
    "data": {
        "summary": {...},
        "statistics": {...}
    }
}
```

#### 6.1.2 图表生成接口（可选，用于调试）

```python
POST /api/v1/operation/generate-charts
Request:
{
    "file_id": int,
    "analysis_request": str,
    "chart_types": List[str]  # 可选，指定图表类型
}
Response:
{
    "success": true,
    "data": {
        "charts": List[Dict]
    }
}
```

### 6.2 修改接口

#### 6.2.1 报告生成接口（修改）

```python
POST /api/v1/operation/generate
Request: (不变)
{
    "session_id": int,
    "file_id": int,
    "analysis_request": str
}
Response: (结构不变，但生成方式改变)
{
    "success": true,
    "data": {
        "report_id": int,
        "content": {
            "text": str,  # 来自Dify
            "charts": List[Dict],  # 来自后端生成
            ...
        }
    }
}
```

### 6.3 内部服务接口

#### 6.3.1 DataExtractor 服务

```python
class DataExtractor:
    def extract(self, file_path: str) -> Dict[str, Any]:
        """提取Excel数据"""
        pass
    
    def get_summary(self, df: DataFrame) -> Dict:
        """获取数据摘要"""
        pass
    
    def get_statistics(self, df: DataFrame) -> Dict:
        """获取统计信息"""
        pass
```

#### 6.3.2 ChartGenerator 服务

```python
class ChartGenerator:
    def generate(
        self, 
        data: Dict[str, Any], 
        analysis_request: str
    ) -> List[Dict]:
        """生成图表配置"""
        pass
    
    def _determine_chart_type(
        self, 
        data: Dict, 
        request: str
    ) -> str:
        """确定图表类型"""
        pass
    
    def _generate_line_chart(self, data: Dict) -> Dict:
        """生成折线图配置"""
        pass
    
    def _generate_bar_chart(self, data: Dict) -> Dict:
        """生成柱状图配置"""
        pass
    
    # ... 其他图表类型
```

---

## 7. 实现步骤

### 7.1 第一阶段：基础架构搭建

#### 步骤1：创建数据提取服务

- [ ] 创建 `backend/app/services/data_extractor.py`
- [ ] 实现 Excel 文件读取功能
- [ ] 实现数据清洗和预处理
- [ ] 实现数据摘要和统计功能
- [ ] 编写单元测试

#### 步骤2：创建图表生成服务

- [ ] 创建 `backend/app/services/chart_generator.py`
- [ ] 实现图表类型判断逻辑
- [ ] 实现基础图表类型生成（折线图、柱状图、饼图）
- [ ] 实现图表配置标准化
- [ ] 编写单元测试

#### 步骤3：修改 Dify 服务

- [ ] 修改 Dify 工作流提示词，明确只生成文字
- [ ] 修改 `parse_echarts_from_text`，不再提取图表
- [ ] 测试 Dify 返回纯文字内容

### 7.2 第二阶段：集成与测试

#### 步骤4：创建报告合并服务

- [ ] 创建 `backend/app/services/report_merger.py`
- [ ] 实现文字和图表合并逻辑
- [ ] 实现报告结构标准化

#### 步骤5：修改报告生成接口

- [ ] 修改 `generate_report` 函数
- [ ] 实现并行处理（数据提取 + Dify 调用）
- [ ] 集成图表生成服务
- [ ] 集成报告合并服务
- [ ] 更新错误处理逻辑

#### 步骤6：测试与优化

- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能测试
- [ ] 修复 bug

### 7.3 第三阶段：增强功能

#### 步骤7：图表类型扩展

- [ ] 支持更多图表类型（散点图、热力图、雷达图等）
- [ ] 实现智能图表选择算法
- [ ] 支持多图表组合

#### 步骤8：数据分析增强

- [ ] 实现数据关联分析
- [ ] 实现趋势分析
- [ ] 实现异常检测

#### 步骤9：前端优化

- [ ] 优化图表渲染性能
- [ ] 添加图表交互功能
- [ ] 优化 PDF 导出

### 7.4 第四阶段：文档与部署

#### 步骤10：文档完善

- [ ] 更新 API 文档
- [ ] 编写使用指南
- [ ] 编写开发文档

#### 步骤11：部署与监控

- [ ] 部署到测试环境
- [ ] 性能监控
- [ ] 错误监控
- [ ] 用户反馈收集

---

## 8. 风险评估与应对

### 8.1 技术风险

#### 风险1：数据提取失败

- **风险描述**：Excel 文件格式复杂，可能导致数据提取失败
- **影响**：高
- **应对措施**：
  - 实现多种 Excel 读取库（pandas, openpyxl, xlrd）
  - 添加数据验证和错误处理
  - 提供详细的错误信息

#### 风险2：图表生成不准确

- **风险描述**：自动生成的图表可能不符合用户需求
- **影响**：中
- **应对措施**：
  - 实现图表类型智能选择
  - 允许用户指定图表类型
  - 提供图表预览和编辑功能（未来）

#### 风险3：性能问题

- **风险描述**：大文件处理可能影响性能
- **影响**：中
- **应对措施**：
  - 实现数据采样（大文件）
  - 异步处理
  - 添加缓存机制

### 8.2 业务风险

#### 风险1：用户体验变化

- **风险描述**：用户可能不习惯新的图表生成方式
- **影响**：低
- **应对措施**：
  - 保持前端界面不变
  - 提供平滑的迁移方案
  - 收集用户反馈

#### 风险2：Dify 工作流需要调整

- **风险描述**：需要修改 Dify 工作流配置
- **影响**：中
- **应对措施**：
  - 更新 Dify 工作流提示词
  - 提供迁移指南
  - 支持向后兼容

### 8.3 兼容性风险

#### 风险1：旧数据兼容

- **风险描述**：旧报告可能包含 Dify 生成的图表
- **影响**：低
- **应对措施**：
  - 保持 `parse_echarts_from_text` 函数（向后兼容）
  - 新报告使用新方式，旧报告保持不变

---

## 9. 性能优化建议

### 9.1 数据提取优化

- **数据采样**：大文件（>10MB）进行采样分析
- **缓存机制**：相同文件的数据提取结果缓存
- **并行处理**：多 Sheet 文件并行处理

### 9.2 图表生成优化

- **配置模板**：使用预定义图表配置模板
- **批量生成**：一次生成多个图表
- **懒加载**：前端按需渲染图表

### 9.3 Dify 调用优化

- **提示词优化**：精简提示词，只请求文字内容
- **超时控制**：设置合理的超时时间
- **重试机制**：失败自动重试

### 9.4 整体性能目标

- **数据提取**：< 2秒（10MB 文件）
- **图表生成**：< 1秒（5个图表）
- **Dify 调用**：< 10秒（文字生成）
- **总响应时间**：< 15秒

---

## 10. 技术选型

### 10.1 数据提取库

- **pandas**：主要使用，功能强大
- **openpyxl**：备用，处理复杂格式
- **xlrd**：备用，处理旧版 Excel

### 10.2 图表生成

- **ECharts**：保持现有选择
- **配置生成**：Python 字典生成 ECharts 配置

### 10.3 数据分析（可选）

- **numpy**：数值计算
- **scipy**：统计分析（未来扩展）

---

## 11. 示例代码结构

### 11.1 数据提取服务示例

```python
# backend/app/services/data_extractor.py
import pandas as pd
from typing import Dict, Any
from loguru import logger

class DataExtractor:
    def extract(self, file_path: str) -> Dict[str, Any]:
        """提取Excel数据"""
        try:
            df = pd.read_excel(file_path)
            
            return {
                "raw_data": df,
                "summary": self._get_summary(df),
                "statistics": self._get_statistics(df)
            }
        except Exception as e:
            logger.error(f"数据提取失败: {e}")
            raise
    
    def _get_summary(self, df: pd.DataFrame) -> Dict:
        """获取数据摘要"""
        return {
            "row_count": len(df),
            "column_count": len(df.columns),
            "columns": df.columns.tolist(),
            "data_types": df.dtypes.astype(str).to_dict(),
            "numeric_columns": df.select_dtypes(include=['number']).columns.tolist(),
            "categorical_columns": df.select_dtypes(include=['object']).columns.tolist()
        }
    
    def _get_statistics(self, df: pd.DataFrame) -> Dict:
        """获取统计信息"""
        numeric_cols = df.select_dtypes(include=['number']).columns
        return {
            "numeric_stats": df[numeric_cols].describe().to_dict(),
            "categorical_counts": {
                col: df[col].value_counts().to_dict()
                for col in df.select_dtypes(include=['object']).columns
            }
        }
```

### 11.2 图表生成服务示例

```python
# backend/app/services/chart_generator.py
from typing import Dict, List, Any
from loguru import logger

class ChartGenerator:
    def generate(
        self, 
        data: Dict[str, Any], 
        analysis_request: str
    ) -> List[Dict]:
        """生成图表配置"""
        charts = []
        
        # 分析数据特征
        summary = data.get("summary", {})
        statistics = data.get("statistics", {})
        
        # 根据分析需求确定图表类型
        chart_types = self._determine_chart_types(
            summary, 
            statistics, 
            analysis_request
        )
        
        # 生成图表
        for chart_type in chart_types:
            chart_config = self._generate_chart(
                chart_type, 
                data, 
                analysis_request
            )
            if chart_config:
                charts.append(chart_config)
        
        return charts
    
    def _determine_chart_types(
        self, 
        summary: Dict, 
        statistics: Dict, 
        request: str
    ) -> List[str]:
        """确定图表类型"""
        chart_types = []
        
        # 根据数据特征和分析需求判断
        numeric_cols = summary.get("numeric_columns", [])
        categorical_cols = summary.get("categorical_columns", [])
        
        if len(numeric_cols) >= 2:
            chart_types.append("line")  # 折线图
            chart_types.append("bar")   # 柱状图
        
        if len(categorical_cols) >= 1:
            chart_types.append("pie")   # 饼图
        
        return chart_types[:3]  # 最多3个图表
    
    def _generate_chart(
        self, 
        chart_type: str, 
        data: Dict, 
        request: str
    ) -> Dict:
        """生成具体图表配置"""
        if chart_type == "line":
            return self._generate_line_chart(data)
        elif chart_type == "bar":
            return self._generate_bar_chart(data)
        elif chart_type == "pie":
            return self._generate_pie_chart(data)
        return None
    
    def _generate_line_chart(self, data: Dict) -> Dict:
        """生成折线图配置"""
        df = data.get("raw_data")
        numeric_cols = df.select_dtypes(include=['number']).columns[:2]
        
        return {
            "type": "line",
            "title": f"{numeric_cols[0]} 趋势分析",
            "config": {
                "title": {"text": f"{numeric_cols[0]} 趋势分析"},
                "tooltip": {"trigger": "axis"},
                "xAxis": {"type": "category", "data": df.index.tolist()},
                "yAxis": {"type": "value"},
                "series": [{
                    "name": numeric_cols[0],
                    "type": "line",
                    "data": df[numeric_cols[0]].tolist()
                }]
            }
        }
    
    # ... 其他图表生成方法
```

### 11.3 报告生成接口修改示例

```python
# backend/app/api/v1/operation.py (修改部分)
async def generate_report(...):
    # ... 前面的代码不变 ...
    
    # 并行处理
    import asyncio
    
    # 任务1：数据提取和图表生成
    async def extract_and_generate_charts():
        extractor = DataExtractor()
        chart_generator = ChartGenerator()
        
        data = extractor.extract(str(file_path))
        charts = chart_generator.generate(data, analysis_request)
        return charts
    
    # 任务2：Dify文字生成
    async def generate_text():
        # 调用Dify（修改提示词，只生成文字）
        result = await DifyService.run_workflow(...)
        report_text = result.get("answer", "")
        return report_text
    
    # 并行执行
    charts_task = extract_and_generate_charts()
    text_task = generate_text()
    
    charts, report_text = await asyncio.gather(
        charts_task,
        text_task
    )
    
    # 合并结果
    report_content = {
        "text": report_text,
        "charts": charts,
        "tables": [],
        "metrics": {}
    }
    
    # ... 后面的代码不变 ...
```

---

## 12. 迁移策略

### 12.1 向后兼容

- 保持 `parse_echarts_from_text` 函数存在
- 新报告使用新方式生成
- 旧报告继续使用原有方式解析

### 12.2 渐进式迁移

1. **第一阶段**：新功能使用新架构
2. **第二阶段**：逐步迁移旧功能
3. **第三阶段**：完全切换到新架构

### 12.3 配置开关

```python
# 配置项：是否使用新架构
USE_NEW_CHART_GENERATION = True  # 默认启用新架构

# 在代码中使用
if USE_NEW_CHART_GENERATION:
    # 使用新架构
else:
    # 使用旧架构（向后兼容）
```

---

## 13. 总结

### 13.1 核心价值

1. **提升准确性**：图表基于真实数据生成
2. **统一标准**：图表样式和类型标准化
3. **性能优化**：减少 AI 处理复杂度
4. **易于维护**：图表生成逻辑集中管理

### 13.2 实施建议

1. **推荐方案**：后端生成图表（方案A）
2. **实施方式**：分阶段实施，保证向后兼容
3. **优先级**：高（提升用户体验和系统稳定性）

### 13.3 后续扩展

- 支持用户自定义图表类型
- 实现图表模板系统
- 支持数据联动分析
- 实现图表智能推荐

---

## 附录

### A. 相关文件清单

**需要新建的文件**：
- `backend/app/services/data_extractor.py`
- `backend/app/services/chart_generator.py`
- `backend/app/services/report_merger.py`

**需要修改的文件**：
- `backend/app/api/v1/operation.py`
- `backend/app/api/v1/operation_batch.py`
- `backend/app/api/v1/operation_custom_batch.py`
- `backend/app/services/dify_service.py`
- `backend/app/utils/echarts_parser.py`（保持向后兼容）

**不需要修改的文件**：
- `frontend/src/views/Operation/components/ReportDisplay.vue`（前端无需修改）
- `backend/app/utils/pdf_generator.py`（PDF生成逻辑不变）

### B. 依赖库清单

**新增依赖**：
- `pandas`：数据分析和处理
- `openpyxl`：Excel 文件读取（pandas 已包含）

**现有依赖**（无需新增）：
- `echarts`：前端图表库（已使用）
- `reportlab`：PDF 生成（已使用）

### C. 测试用例示例

```python
# tests/test_data_extractor.py
def test_extract_excel():
    extractor = DataExtractor()
    result = extractor.extract("test_data.xlsx")
    assert "summary" in result
    assert "statistics" in result

# tests/test_chart_generator.py
def test_generate_charts():
    generator = ChartGenerator()
    data = {...}  # 测试数据
    charts = generator.generate(data, "分析需求")
    assert len(charts) > 0
    assert charts[0]["type"] in ["line", "bar", "pie"]
```

---

**文档版本**：v1.0  
**创建日期**：2025-12-03  
**最后更新**：2025-12-03

