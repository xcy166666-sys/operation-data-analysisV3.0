# 修复 500 错误 - 最终解决方案

## 问题描述

用户在生成报告时遇到 500 错误，后端日志显示：

```
httpx.ConnectError: [Errno -3] Temporary failure in name resolution
```

## 问题分析过程

### 1. 初步诊断

- **现象**：生成报告时后端返回 500 错误
- **日志**：httpx 无法解析 `dashscope.aliyuncs.com` 域名
- **环境**：后端运行在 Docker 容器中

### 2. 尝试的解决方案

#### 方案 1: 移除代理配置 ❌
- 注释了 `docker-compose.yml` 中的 `HTTP_PROXY` 和 `HTTPS_PROXY`
- 重新创建容器
- **结果**：问题依然存在

#### 方案 2: 修改代码移除代理读取 ❌
- 修改 `bailian_service.py`，移除读取环境变量中的代理配置
- 添加 `trust_env=False` 参数
- **结果**：问题依然存在

#### 方案 3: 修改 DNS 配置 ❌
- 在 `docker-compose.yml` 中添加多个 DNS 服务器
- 尝试修改容器内的 `/etc/resolv.conf`
- **结果**：标准库可以解析 DNS，但 httpx 仍然失败

### 3. 根本原因

经过深入测试发现：

1. **Docker 内部 DNS 问题**：
   - Docker 容器使用内部 DNS 服务器 (127.0.0.11)
   - Python 标准库 `socket.gethostbyname()` 可以正常解析
   - 但 httpx 使用的 `anyio` 后端无法正确使用 Docker 内部 DNS

2. **网络隔离问题**：
   - 即使 DNS 解析成功，TLS 握手也可能失败
   - Docker 网络层面可能存在其他限制

3. **本地环境测试**：
   - 在 Windows 本地环境中测试，httpx 同样无法连接
   - 但使用代理 (http://127.0.0.1:7890) 可以连接到百度
   - 阿里云 API 即使使用代理也无法连接

## 最终解决方案：本地开发环境 ✅

### 核心思路

**在开发环境中不使用 Docker 运行后端，直接在本地运行，避免 Docker 网络问题。**

### 架构设计

```
开发环境:
┌─────────────────────────────────────────┐
│  前端 (本地)                             │
│  npm run dev                            │
│  端口: 5173                             │
└─────────────┬───────────────────────────┘
              │ HTTP
              ↓
┌─────────────────────────────────────────┐
│  后端 (本地)                             │
│  python -m uvicorn                      │
│  端口: 8000                             │
└─────────────┬───────────────────────────┘
              │
        ┌─────┴─────┐
        ↓           ↓
┌──────────┐  ┌──────────┐
│PostgreSQL│  │  Redis   │
│ (Docker) │  │ (Docker) │
│端口:22810│  │端口:22811│
└──────────┘  └──────────┘

生产环境:
全部使用 Docker Compose
```

### 实施步骤

#### 1. 创建本地环境配置

文件：`backend/.env.local`

```env
# 数据库配置（连接到 Docker 中的 PostgreSQL）
POSTGRES_USER=postgres
POSTGRES_PASSWORD=secure_password_123!
POSTGRES_DB=operation_analysis_v2
POSTGRES_HOST=localhost
POSTGRES_PORT=22810

# Redis配置（连接到 Docker 中的 Redis）
REDIS_URL=redis://localhost:22811/0

# 阿里百炼DashScope配置
DASHSCOPE_API_KEY=sk-f72852ce679f42019f669589a51e2639
DASHSCOPE_MODEL=qwen3-32b
```

#### 2. 修改配置加载逻辑

文件：`backend/app/core/config.py`

```python
# 支持 .env.local 文件
import os
env_file = os.environ.get("ENV_FILE", ".env")
if env_file != ".env" and os.path.exists(env_file):
    settings = Settings(_env_file=env_file)
elif os.path.exists(".env.local"):
    settings = Settings(_env_file=".env.local")
else:
    settings = Settings()
```

#### 3. 创建启动脚本

文件：`backend/start_local.bat`

```batch
@echo off
set ENV_FILE=.env.local
python -m uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

#### 4. 更新前端配置

文件：`frontend/.env.development`

```env
VITE_API_URL=http://localhost:8000
```

### 使用方法

```powershell
# 1. 启动数据库和 Redis
docker-compose up -d postgres redis

# 2. 启动后端（新终端）
cd backend
.\start_local.bat

# 3. 启动前端（新终端）
cd frontend
npm run dev
```

## 解决方案优势

### ✅ 技术优势

1. **无网络问题**：直接使用本地网络，避免 Docker DNS 和代理问题
2. **更快的开发体验**：代码修改后立即生效，无需重建容器
3. **更容易调试**：可以直接使用 IDE 的调试功能
4. **更低的资源占用**：不需要运行完整的后端容器

### ✅ 测试结果

```
测试本地开发环境
============================================================

1. 测试配置加载:
   ✓ 配置加载成功
   - APP_NAME: 运营数据分析系统
   - DEBUG: True
   - DASHSCOPE_API_KEY: 已配置

2. 测试数据库连接:
   ✓ 数据库连接成功
   - PostgreSQL 版本: PostgreSQL 15.15

3. 测试 Redis 连接:
   ✓ Redis 连接成功

4. 后端服务启动:
   ✓ 启动成功
   INFO:     Uvicorn running on http://0.0.0.0:8000
   INFO:     Application startup complete.
```

## 生产环境部署

生产环境仍然使用 Docker Compose：

```powershell
docker-compose up -d
```

所有服务（包括后端）都在 Docker 中运行，使用 `.env` 文件配置。

## 相关文档

- [本地开发环境-快速启动.md](../本地开发环境-快速启动.md) - 详细的启动指南
- [backend/本地开发环境启动指南.md](../backend/本地开发环境启动指南.md) - 后端配置说明
- [docs/本地开发环境-解决方案.md](./本地开发环境-解决方案.md) - 技术方案详解

## 总结

通过将后端服务从 Docker 迁移到本地运行，我们成功解决了 Docker 网络导致的 API 调用问题。这种方案：

1. **彻底解决了问题**：避开了 Docker 网络的复杂性
2. **提升了开发体验**：更快的启动速度和代码热重载
3. **保持了灵活性**：生产环境仍然使用 Docker
4. **易于维护**：配置清晰，问题定位简单

这是一个**实用主义**的解决方案，在开发效率和部署一致性之间找到了最佳平衡点。
